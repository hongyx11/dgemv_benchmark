GNU 8.2.0 is now loaded
Intel Parallel Studio 2020 is now loaded
mkdir -p bin
mkdir -p log
mkdir -p plots
gcc -O3 dgemv.c  \
-DUSE_INTEL -DUSE_DOUBLE \
-DMKL_ILP64 -m64 -I/sw/csi/intel/2020/compilers_and_libraries/linux/mkl/include \
-o bin/inteldouble \
-Wl,--start-group /sw/csi/intel/2020/compilers_and_libraries/linux/mkl/lib/intel64/libmkl_intel_ilp64.a \
/sw/csi/intel/2020/compilers_and_libraries/linux/mkl/lib/intel64/libmkl_gnu_thread.a /sw/csi/intel/2020/compilers_and_libraries/linux/mkl/lib/intel64/libmkl_core.a \
-Wl,--end-group -lgomp -lpthread -lm -ldl
gcc -O3 dgemv.c \
-DUSE_INTEL \
-DMKL_ILP64 -m64 -I/sw/csi/intel/2020/compilers_and_libraries/linux/mkl/include \
-o bin/intelsingle \
-Wl,--start-group /sw/csi/intel/2020/compilers_and_libraries/linux/mkl/lib/intel64/libmkl_intel_ilp64.a \
/sw/csi/intel/2020/compilers_and_libraries/linux/mkl/lib/intel64/libmkl_gnu_thread.a /sw/csi/intel/2020/compilers_and_libraries/linux/mkl/lib/intel64/libmkl_core.a \
-Wl,--end-group -lgomp -lpthread -lm -ldl

 This benchmark computes real vector y=alpha*A*x+beta*y, where A is matrix, y and x are vectors alpha and beta are scalars

 1) m : 128 n: 128 alpha: 1.000000 beta: 0.000000 nruns: 100

 2) use intel, mkl use 40 threads and single precision on cn605-25-l.

 3) Intializing matrix data with random number range from 0 to 1.

 4) Finish init, start to test, nruns is 100 warmup is 10 rounds. 

 5) quick look at the test time mean (seconds) and var 1.143e-05, 3.962e-12. 

 6) Deallocating memory and write results to files. 


 This benchmark computes real vector y=alpha*A*x+beta*y, where A is matrix, y and x are vectors alpha and beta are scalars

 1) m : 256 n: 256 alpha: 1.000000 beta: 0.000000 nruns: 100

 2) use intel, mkl use 40 threads and single precision on cn605-25-l.

 3) Intializing matrix data with random number range from 0 to 1.

 4) Finish init, start to test, nruns is 100 warmup is 10 rounds. 

 5) quick look at the test time mean (seconds) and var 1.980e-05, 1.872e-11. 

 6) Deallocating memory and write results to files. 


 This benchmark computes real vector y=alpha*A*x+beta*y, where A is matrix, y and x are vectors alpha and beta are scalars

 1) m : 512 n: 512 alpha: 1.000000 beta: 0.000000 nruns: 100

 2) use intel, mkl use 40 threads and single precision on cn605-25-l.

 3) Intializing matrix data with random number range from 0 to 1.

 4) Finish init, start to test, nruns is 100 warmup is 10 rounds. 

 5) quick look at the test time mean (seconds) and var 2.177e-05, 2.495e-11. 

 6) Deallocating memory and write results to files. 


 This benchmark computes real vector y=alpha*A*x+beta*y, where A is matrix, y and x are vectors alpha and beta are scalars

 1) m : 1024 n: 1024 alpha: 1.000000 beta: 0.000000 nruns: 100

 2) use intel, mkl use 40 threads and single precision on cn605-25-l.

 3) Intializing matrix data with random number range from 0 to 1.

 4) Finish init, start to test, nruns is 100 warmup is 10 rounds. 

 5) quick look at the test time mean (seconds) and var 5.013e-05, 2.068e-11. 

 6) Deallocating memory and write results to files. 


 This benchmark computes real vector y=alpha*A*x+beta*y, where A is matrix, y and x are vectors alpha and beta are scalars

 1) m : 2048 n: 2048 alpha: 1.000000 beta: 0.000000 nruns: 100

 2) use intel, mkl use 40 threads and single precision on cn605-25-l.

 3) Intializing matrix data with random number range from 0 to 1.

 4) Finish init, start to test, nruns is 100 warmup is 10 rounds. 

 5) quick look at the test time mean (seconds) and var 5.647e-05, 2.494e-11. 

 6) Deallocating memory and write results to files. 


 This benchmark computes real vector y=alpha*A*x+beta*y, where A is matrix, y and x are vectors alpha and beta are scalars

 1) m : 4096 n: 4096 alpha: 1.000000 beta: 0.000000 nruns: 100

 2) use intel, mkl use 40 threads and single precision on cn605-25-l.

 3) Intializing matrix data with random number range from 0 to 1.

 4) Finish init, start to test, nruns is 100 warmup is 10 rounds. 

 5) quick look at the test time mean (seconds) and var 8.110e-04, 3.477e-10. 

 6) Deallocating memory and write results to files. 


 This benchmark computes real vector y=alpha*A*x+beta*y, where A is matrix, y and x are vectors alpha and beta are scalars

 1) m : 8192 n: 8192 alpha: 1.000000 beta: 0.000000 nruns: 100

 2) use intel, mkl use 40 threads and single precision on cn605-25-l.

 3) Intializing matrix data with random number range from 0 to 1.

 4) Finish init, start to test, nruns is 100 warmup is 10 rounds. 

 5) quick look at the test time mean (seconds) and var 3.392e-03, 1.361e-10. 

 6) Deallocating memory and write results to files. 


 This benchmark computes real vector y=alpha*A*x+beta*y, where A is matrix, y and x are vectors alpha and beta are scalars

 1) m : 128 n: 128 alpha: 1.000000 beta: 0.000000 nruns: 100

 2) use intel, mkl use 40 threads and double precision on cn605-25-l.

 3) Intializing matrix data with random number range from 0 to 1.

 4) Finish init, start to test, nruns is 100 warmup is 10 rounds. 

 5) quick look at the test time mean (seconds) and var 1.137e-05, 3.868e-12. 

 6) Deallocating memory and write results to files. 


 This benchmark computes real vector y=alpha*A*x+beta*y, where A is matrix, y and x are vectors alpha and beta are scalars

 1) m : 256 n: 256 alpha: 1.000000 beta: 0.000000 nruns: 100

 2) use intel, mkl use 40 threads and double precision on cn605-25-l.

 3) Intializing matrix data with random number range from 0 to 1.

 4) Finish init, start to test, nruns is 100 warmup is 10 rounds. 

 5) quick look at the test time mean (seconds) and var 2.899e-05, 3.481e-11. 

 6) Deallocating memory and write results to files. 


 This benchmark computes real vector y=alpha*A*x+beta*y, where A is matrix, y and x are vectors alpha and beta are scalars

 1) m : 512 n: 512 alpha: 1.000000 beta: 0.000000 nruns: 100

 2) use intel, mkl use 40 threads and double precision on cn605-25-l.

 3) Intializing matrix data with random number range from 0 to 1.

 4) Finish init, start to test, nruns is 100 warmup is 10 rounds. 

 5) quick look at the test time mean (seconds) and var 3.562e-05, 3.560e-11. 

 6) Deallocating memory and write results to files. 


 This benchmark computes real vector y=alpha*A*x+beta*y, where A is matrix, y and x are vectors alpha and beta are scalars

 1) m : 1024 n: 1024 alpha: 1.000000 beta: 0.000000 nruns: 100

 2) use intel, mkl use 40 threads and double precision on cn605-25-l.

 3) Intializing matrix data with random number range from 0 to 1.

 4) Finish init, start to test, nruns is 100 warmup is 10 rounds. 

 5) quick look at the test time mean (seconds) and var 5.141e-05, 3.392e-10. 

 6) Deallocating memory and write results to files. 


 This benchmark computes real vector y=alpha*A*x+beta*y, where A is matrix, y and x are vectors alpha and beta are scalars

 1) m : 2048 n: 2048 alpha: 1.000000 beta: 0.000000 nruns: 100

 2) use intel, mkl use 40 threads and double precision on cn605-25-l.

 3) Intializing matrix data with random number range from 0 to 1.

 4) Finish init, start to test, nruns is 100 warmup is 10 rounds. 

 5) quick look at the test time mean (seconds) and var 2.250e-04, 1.272e-10. 

 6) Deallocating memory and write results to files. 


 This benchmark computes real vector y=alpha*A*x+beta*y, where A is matrix, y and x are vectors alpha and beta are scalars

 1) m : 4096 n: 4096 alpha: 1.000000 beta: 0.000000 nruns: 100

 2) use intel, mkl use 40 threads and double precision on cn605-25-l.

 3) Intializing matrix data with random number range from 0 to 1.

 4) Finish init, start to test, nruns is 100 warmup is 10 rounds. 

 5) quick look at the test time mean (seconds) and var 1.234e-03, 5.380e-11. 

 6) Deallocating memory and write results to files. 


 This benchmark computes real vector y=alpha*A*x+beta*y, where A is matrix, y and x are vectors alpha and beta are scalars

 1) m : 8192 n: 8192 alpha: 1.000000 beta: 0.000000 nruns: 100

 2) use intel, mkl use 40 threads and double precision on cn605-25-l.

 3) Intializing matrix data with random number range from 0 to 1.

 4) Finish init, start to test, nruns is 100 warmup is 10 rounds. 

 5) quick look at the test time mean (seconds) and var 7.476e-03, 7.723e-10. 

 6) Deallocating memory and write results to files. 

